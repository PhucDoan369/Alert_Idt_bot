<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Trader Dashboard - 4TF</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <style>
      body { font-family: Inter, system-ui, Arial; margin:12px; background:#002044; color:#e6eef8; }
      .controls { display:flex; gap:8px; align-items:center; margin-bottom:12px; }
      .grid { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
      .panel { background:#111827; padding:8px; border-radius:8px; }
      .chart { height:320px; }
      .minor { font-size:12px; color:#e6eef8; }
      button { padding:6px 12px; border:none; border-radius:6px; cursor:pointer; font-weight:600; }
    </style>
</head>
<body>

<div class="controls">
  <label>Symbol:
    <input id="symbolInput" type="text" value="BTCUSDT" />
  </label>
  <label>Limit:
    <input id="limitInput" type="number" value="100" min="30" max="500" />
  </label>
  <button id="viewBtn" style="background:#0ea5a6;color:#042024;">Views</button>
  <span id="countdown">20s</span>
  <button id="captureBtn" style="background:#3b82f6;color:#fff;">üì∏ Capture & Send Test</button>
</div>

<div class="grid">
  <div class="panel"><div>5m <span id="info-5m" class="minor"></span></div><div class="chart" id="chart-5m"></div></div>
  <div class="panel"><div>15m <span id="info-15m" class="minor"></span></div><div class="chart" id="chart-15m"></div></div>
  <div class="panel"><div>1h <span id="info-1h" class="minor"></span></div><div class="chart" id="chart-1h"></div></div>
  <div class="panel"><div>4h <span id="info-4h" class="minor"></span></div><div class="chart" id="chart-4h"></div></div>
</div>

<script>
const TELEGRAM_TOKEN = "8413345761:AAFy_T3G9afclAqO_DOL23y-83Z_VnxE0sw";
const TELEGRAM_CHATID = "6549625165"; 

const timeframes = [
  {key:'5m', interval:'5m', panelId:'chart-5m', infoId:'info-5m', cooldownMs: 15*60*1000},
  {key:'15m', interval:'15m', panelId:'chart-15m', infoId:'info-15m', cooldownMs: 60*60*1000},
  {key:'1h', interval:'1h', panelId:'chart-1h', infoId:'info-1h', cooldownMs: 4*60*60*1000},
  {key:'4h', interval:'4h', panelId:'chart-4h', infoId:'info-4h', cooldownMs: 10*60*60*1000},
];
const BB_PERIOD = 20, BB_MULT = 2;
const charts = {}, lastAlertAt = {};

for (const tf of timeframes) {
  const chart = LightweightCharts.createChart(document.getElementById(tf.panelId), {
    layout:{ background:{color:'#cae1fa'}, textColor:'#002044' },
    rightPriceScale:{ borderVisible:false },
    timeScale:{ borderVisible:false }
  });
  const candleSeries = chart.addCandlestickSeries({ upColor:'#26a69a', downColor:'#ef5350', borderVisible:false });
  const upperSeries = chart.addLineSeries({ color:'#7c3aed', lineWidth:1 });
  const middleSeries = chart.addLineSeries({ color:'#60a5fa', lineWidth:1 });
  const lowerSeries = chart.addLineSeries({ color:'#7c3aed', lineWidth:1 });
  charts[tf.key] = { chart, candleSeries, upperSeries, middleSeries, lowerSeries, infoEl: document.getElementById(tf.infoId) };
}

async function fetchKlines(symbol, interval, limit=100){
  const url=`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const res=await fetch(url); const data=await res.json();
  return data.map(k=>({time:Math.floor(k[0]/1000),open:+k[1],high:+k[2],low:+k[3],close:+k[4],volume:+k[5]}));
}
function sma(values, i, period){ if(i+1<period) return null; let sum=0; for(let j=i-period+1;j<=i;j++) sum+=values[j]; return sum/period; }
function stddev(values,i,period,mean){ let s=0; for(let j=i-period+1;j<=i;j++){let d=values[j]-mean; s+=d*d;} return Math.sqrt(s/period); }

function prepareSeries(klines){
  const closes=klines.map(k=>k.close);
  const upper=[],middle=[],lower=[];
  for(let i=0;i<closes.length;i++){
    const m=sma(closes,i,BB_PERIOD); if(m!=null){
      const sd=stddev(closes,i,BB_PERIOD,m);
      middle.push({time:klines[i].time,value:m});
      upper.push({time:klines[i].time,value:m+BB_MULT*sd});
      lower.push({time:klines[i].time,value:m-BB_MULT*sd});
    }
  }
  return {candleData:klines,upper,middle,lower};
}

function addMarker(tfKey, time, price, type){
  const marker = {
    time: time,
    position: type === "upper" ? 'aboveBar' : 'belowBar',
    color: type === "upper" ? 'red' : 'red',
    shape: type === "upper" ? 'arrowDown' : 'arrowUp',
    text: type === "upper" ? 'BB' : 'BB',
  };
  // preserve existing markers
  charts[tfKey].markers = charts[tfKey].markers || [];
  charts[tfKey].markers.push(marker);
  charts[tfKey].candleSeries.setMarkers(charts[tfKey].markers);
}

async function sendTelegram(msg) {
  try {
    // 1. Load l·∫°i to√†n b·ªô chart
    await loadAll();

    // 2. ƒê·ª£i chart render xong (gi·ªëng nh∆∞ sleep trong Java)
    await new Promise(r => setTimeout(r, 3000)); // 1s delay

    // 3. Ch·ª•p ·∫£nh grid
    const gridEl = document.querySelector(".grid");
    const canvas = await html2canvas(gridEl, {
      backgroundColor: "#cae1fa",
      scale: 3
    });

    // 4. Convert sang blob
    const blob = await new Promise(r => canvas.toBlob(r, "image/png"));

    // 5. G·ª≠i l√™n Telegram
    const fd = new FormData();
    fd.append("chat_id", TELEGRAM_CHATID);
    fd.append("caption", msg);
    fd.append("photo", blob, "charts.png");

    await fetch(`https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendPhoto`, {
      method: "POST",
      body: fd
    });

    console.log("‚úÖ ƒê√£ g·ª≠i ·∫£nh Telegram th√†nh c√¥ng");
  } catch (err) {
    console.error("‚ùå L·ªói khi g·ª≠i Telegram:", err);
  }
}
function checkAlerts(tfKey, klines, cooldownMs, symbol){
  if (!klines || klines.length < BB_PERIOD) return null;

  // kh·ªüi t·∫°o c·∫•u tr√∫c cooldown n·∫øu ch∆∞a c√≥
  if (!lastAlertAt[tfKey]) lastAlertAt[tfKey] = { upper: 0, lower: 0 };

  const last = klines[klines.length - 1];      // c√¢y n·∫øn cu·ªëi
  const closes = klines.map(k => k.close);
  const idx = closes.length - 1;
  const m = sma(closes, idx, BB_PERIOD);
  if (m === null) return null;
  const sd = stddev(closes, idx, BB_PERIOD, m);
  const upper = m + BB_MULT * sd;
  const lower = m - BB_MULT * sd;

  const now = Date.now();
  const msgs = [];

  // 1) Wick ch·∫°m BB tr√™n
  if (last.high >= upper) {
    if (now - lastAlertAt[tfKey].upper >= cooldownMs) {
      addMarker(tfKey, last.time, last.high, "upper");
      lastAlertAt[tfKey].upper = now;
      msgs.push(`[TOUCH] ${symbol} ${tfKey} HIGH ${last.high} >= BB_TOP ${upper.toFixed(8)}`);
    }
  }

  // 2) Wick ch·∫°m BB d∆∞·ªõi
  if (last.low <= lower) {
    if (now - lastAlertAt[tfKey].lower >= cooldownMs) {
      addMarker(tfKey, last.time, last.low, "lower");
      lastAlertAt[tfKey].lower = now;
      msgs.push(`[TOUCH] ${symbol} ${tfKey} LOW ${last.low} <= BB_BOT ${lower.toFixed(8)}`);
    }
  }

  // ‚úÖ return ph·∫£i n·∫±m b√™n trong function
  return msgs.length ? msgs.join("\n") : null;
}


let symbol=document.getElementById('symbolInput').value.trim().toUpperCase();
async function loadAll(symbol){
  let limit = parseInt(document.getElementById('limitInput').value) || 100;
  let alerts = [];

  for (const tf of timeframes) {
    try {
      const klines = await fetchKlines(symbol, tf.interval, limit);
      const prep = prepareSeries(klines);

      charts[tf.key].candleSeries.setData(prep.candleData);
      charts[tf.key].upperSeries.setData(prep.upper);
      charts[tf.key].middleSeries.setData(prep.middle);
      charts[tf.key].lowerSeries.setData(prep.lower);

      charts[tf.key].infoEl.textContent = 
        `last ${new Date(klines.at(-1).time*1000).toLocaleString()} close ${klines.at(-1).close}`;

      charts[tf.key].chart.timeScale().fitContent();
      charts[tf.key].chart.timeScale().applyOptions({
        rightOffset: 8,
        barSpacing: 9
      });

      const alertMsg = checkAlerts(tf.key, klines, tf.cooldownMs, symbol);
      if (alertMsg) alerts.push(alertMsg);

    } catch (e) {
      console.error(e);
    }
  }

  if (alerts.length > 0) {
    await sendTelegram(alerts.join("\n"));
  }
}

const symbols = ["BTCUSDT", "ETHUSDT"];
let currentIndex = 0;

async function cycleLoad(){
  const symbol = symbols[currentIndex];
  console.log("ƒêang load:", symbol);
  await loadAll(symbol);

  // xoay v√≤ng
  currentIndex = (currentIndex + 1) % symbols.length;
}

// ch·∫°y l·∫ßn ƒë·∫ßu
cycleLoad();

// l·∫∑p l·∫°i sau m·ªói 15s
setInterval(cycleLoad, 15000);




// auto reload
let countdown=20,timer;
function startCountdown(){
  clearInterval(timer); countdown=20;
  timer=setInterval(()=>{countdown--;document.getElementById('countdown').textContent=countdown+"s";if(countdown<=0){loadAll();countdown=20;}},1000);
}
document.getElementById('viewBtn').addEventListener('click',()=>{loadAll();startCountdown();});
document.getElementById('captureBtn').addEventListener('click',()=>sendTelegram("üì∏ Test capture t·ª´ dashboard"));

loadAll(); startCountdown();
</script>
</body>
</html>
