<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Trader Dashboard - 4TF</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <style>
    body {
      font-family: Inter, system-ui, Arial;
      margin: 12px;
      background: #002044;
      color: #e6eef8;
    }
    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
    }
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .panel {
      background: #111827;
      padding: 8px;
      border-radius: 8px;
    }
    .chart {
      height: 320px;
    }
    .minor {
      font-size: 12px;
      color: #e6eef8;
    }
    button {
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="controls">
<h1 id="currentSymbol" style="margin-left:12px;font-weight:bold;color:#22d3ee;">Symbol: ...</h1>
<button id="btnTopLiquidity">Top 30 Coin</button>
<ul id="topLiquidityList"></ul>
  </div>

  <div class="grid">

    <div class="panel">
      <div>1h <span id="info-1h" class="minor"></span></div>
      <div class="chart" id="chart-1h"></div>
    </div>
    <div class="panel">
      <div>4h <span id="info-4h" class="minor"></span></div>
      <div class="chart" id="chart-4h"></div>
    </div>
        <div class="panel">
      <div>1d<span id="info-1d" class="minor"></span></div>
      <div class="chart" id="chart-1d"></div>
    </div>
  </div>

  <script>



let topSymbols = []; // üü¢ Bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u danh s√°ch symbol
let symbolcoin = "";

document.getElementById('btnTopLiquidity').addEventListener('click', async () => {
  const btn = document.getElementById('btnTopLiquidity');
  const list = document.getElementById('topLiquidityList');
  btn.disabled = true;
  btn.textContent = 'ƒêang t·∫£i...';

  try {
    // G·ªçi API 24h ticker
    const res = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
    const data = await res.json();

    // S·∫Øp x·∫øp theo volume USD gi·∫£m d·∫ßn
    const top30 = data
      .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
      .slice(0, 30);

    // üü° C·∫≠p nh·∫≠t danh s√°ch symbol to√†n c·ª•c
    topSymbols = top30.map(item => item.symbol);

    console.log("‚úÖ topSymbols:", topSymbols);

    // üî• G·ªçi lu√¥n qu√©t to√†n b·ªô symbol
    await scanAllSymbols();

    // Hi·ªÉn th·ªã danh s√°ch
    list.innerHTML = top30
      .map(
        (item, i) =>
          `<li>${i + 1}. <strong>${item.symbol}</strong> ‚Äî Volume: ${parseFloat(item.quoteVolume).toLocaleString()} USDT</li>`
      )
      .join('');

  } catch (err) {
    console.error('L·ªói khi t·∫£i d·ªØ li·ªáu:', err);
    list.innerHTML = '<li>L·ªói khi t·∫£i d·ªØ li·ªáu!</li>';
  } finally {
    btn.disabled = false;
    btn.textContent = 'Top 30 Coin Thanh Kho·∫£n Cao Nh·∫•t';
  }
});

async function scanAllSymbols() {
  for (const symbol of topSymbols) {
    symbolcoin = symbol;
    console.log(`üîç ƒêang qu√©t ${symbol}...`);
    await loadAll(symbol); // ch·∫°y t·ª´ng coin
    await new Promise(r => setTimeout(r, 15000)); // ngh·ªâ 8s ƒë·ªÉ tr√°nh spam API
  }
}


    const TELEGRAM_TOKEN = "8413345761:AAFy_T3G9afclAqO_DOL23y-83Z_VnxE0sw";
    const TELEGRAM_CHATID = "6549625165";
    let scanall = "no"; 
    const timeframes = [
      { key: '1h', interval: '1h', panelId: 'chart-1h', infoId: 'info-1h', cooldownMs: 4 * 60 * 60 * 1000 },
      { key: '4h', interval: '4h', panelId: 'chart-4h', infoId: 'info-4h', cooldownMs: 10 * 60 * 60 * 1000 },
      { key: '1d', interval: '1d', panelId: 'chart-1d', infoId: 'info-1d', cooldownMs: 10 *60 * 60 * 1000 }
    ];

    const BB_PERIOD = 20, BB_MULT = 2;
    const charts = {}, lastAlertAt = {};

    for (const tf of timeframes) {
      const chart = LightweightCharts.createChart(document.getElementById(tf.panelId), {
        layout: { background: { color: '#cae1fa' }, textColor: '#002044' },
        rightPriceScale: { borderVisible: false },
        timeScale: { borderVisible: false }
      });

      const candleSeries = chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        borderVisible: false
      });

      const upperSeries = chart.addLineSeries({ color: '#7c3aed', lineWidth: 1 });
      const middleSeries = chart.addLineSeries({ color: '#60a5fa', lineWidth: 1 });
      const lowerSeries = chart.addLineSeries({ color: '#7c3aed', lineWidth: 1 });

      charts[tf.key] = {
        chart, candleSeries, upperSeries, middleSeries, lowerSeries,
        infoEl: document.getElementById(tf.infoId)
      };
    }

    async function fetchKlines(symbol, interval, limit = 150) {
      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      const res = await fetch(url);
      const data = await res.json();
      return data.map(k => ({
        time: Math.floor(k[0] / 1000),
        open: +k[1], high: +k[2], low: +k[3], close: +k[4], volume: +k[5]
      }));
    }

    function sma(values, i, period) {
      if (i + 1 < period) return null;
      let sum = 0;
      for (let j = i - period + 1; j <= i; j++) sum += values[j];
      return sum / period;
    }

    function stddev(values, i, period, mean) {
      let s = 0;
      for (let j = i - period + 1; j <= i; j++) {
        let d = values[j] - mean;
        s += d * d;
      }
      return Math.sqrt(s / period);
    }

    function prepareSeries(klines) {
      const closes = klines.map(k => k.close);
      const upper = [], middle = [], lower = [];

      for (let i = 0; i < closes.length; i++) {
        const m = sma(closes, i, BB_PERIOD);
        if (m != null) {
          const sd = stddev(closes, i, BB_PERIOD, m);
          middle.push({ time: klines[i].time, value: m });
          upper.push({ time: klines[i].time, value: m + BB_MULT * sd });
          lower.push({ time: klines[i].time, value: m - BB_MULT * sd });
        }
      }
      return { candleData: klines, upper, middle, lower };
    }

    function addMarker(tfKey, time, price, type) {
      const marker = {
        time,
        position: type === "upper" ? 'aboveBar' : 'belowBar',
        color: 'red',
        shape: type === "upper" ? 'arrowDown' : 'arrowUp',
        text: 'BB'
      };
      charts[tfKey].markers = charts[tfKey].markers || [];
      charts[tfKey].markers.push(marker);
      charts[tfKey].candleSeries.setMarkers(charts[tfKey].markers);
    }

    async function sendTelegram(msg) {
      try {// load l·∫°i chart
        await new Promise(r => setTimeout(r, 3000)); // ƒë·ª£i render

        const gridEl = document.querySelector(".grid");
        const canvas = await html2canvas(gridEl, { backgroundColor: "#cae1fa", scale: 2 });
        const blob = await new Promise(r => canvas.toBlob(r, "image/png"));

        const fd = new FormData();
        fd.append("chat_id", TELEGRAM_CHATID);
        fd.append("caption", msg);
        fd.append("photo", blob, "charts.png");

        await fetch(`https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendPhoto`, { method: "POST", body: fd });
        console.log("‚úÖ ƒê√£ g·ª≠i ·∫£nh Telegram th√†nh c√¥ng");
      } catch (err) {
        console.error("‚ùå L·ªói khi g·ª≠i Telegram:", err);
      }
    }

    function checkAlerts(tfKey, klines, cooldownMs, symbol) {
      if (!klines || klines.length < BB_PERIOD) return null;
      if (!lastAlertAt[tfKey]) lastAlertAt[tfKey] = { upper: 0, lower: 0 };

      const last = klines[klines.length - 1];
      const closes = klines.map(k => k.close);
      const idx = closes.length - 1;

      const m = sma(closes, idx, BB_PERIOD);
      if (m === null) return null;

      const sd = stddev(closes, idx, BB_PERIOD, m);
      const upper = m + BB_MULT * sd;
      const lower = m - BB_MULT * sd;
      const now = Date.now();

      const msgs = [];
      if (last.high >= upper && now - lastAlertAt[tfKey].upper >= cooldownMs) {
        addMarker(tfKey, last.time, last.high, "upper");
        lastAlertAt[tfKey].upper = now;
        msgs.push(`[TOUCH] ${symbol} ${tfKey} HIGH ${last.high} >= BB_TOP ${upper.toFixed(8)}`);
      }
      if (last.low <= lower && now - lastAlertAt[tfKey].lower >= cooldownMs) {
        addMarker(tfKey, last.time, last.low, "lower");
        lastAlertAt[tfKey].lower = now;
        msgs.push(`[TOUCH] ${symbol} ${tfKey} LOW ${last.low} <= BB_BOT ${lower.toFixed(8)}`);
      }
      return msgs.length ? msgs.join("\n") : null;
    }

    async function loadAll(symbol) {
      document.getElementById('currentSymbol').textContent = "Symbol: " + symbol;
      let limit = 150;
      let alerts = [];

      for (const tf of timeframes) {
        try {
          const klines = await fetchKlines(symbol, tf.interval, limit);
          const prep = prepareSeries(klines);

          charts[tf.key].candleSeries.setData(prep.candleData);
          charts[tf.key].upperSeries.setData(prep.upper);
          charts[tf.key].middleSeries.setData(prep.middle);
          charts[tf.key].lowerSeries.setData(prep.lower);
          charts[tf.key].infoEl.textContent =
            `last ${new Date(klines.at(-1).time * 1000).toLocaleString()} close ${klines.at(-1).close}`;

          charts[tf.key].chart.timeScale().fitContent();
      if (tf.key === "1h") {
  charts[tf.key].chart.timeScale().applyOptions({
    handleScroll: { mouseWheel: true, pressedMouseMove: true },
    handleScale: { mouseWheel: true, pinch: true },
    rightOffset: 8,
    barSpacing: 9 * 0.7
  });
} 
      else if (tf.key === "4h") {
  charts[tf.key].chart.timeScale().applyOptions({
    handleScroll: { mouseWheel: true, pressedMouseMove: true },
    handleScale: { mouseWheel: true, pinch: true },
    rightOffset: 8,
    barSpacing: 9 * 0.7
  });
} 
else {
  charts[tf.key].chart.timeScale().applyOptions({
    rightOffset: 8,
    barSpacing: 9 *0.8
  });
}

          const alertMsg = checkAlerts(tf.key, klines, tf.cooldownMs, symbol);
          if (alertMsg) alerts.push(alertMsg);
        } catch (e) {
          console.error(e);
        }
      }
      if (alerts.length > 0) await sendTelegram(alerts.join("\n"));
    }


    document.getElementById('viewBtn').addEventListener('click', () => {
      if(scanall==="no"){
      loadAll();
      startCountdown();}
    });

    document.getElementById('captureBtn').addEventListener('click', () => sendTelegram("üì∏ Test capture t·ª´ dashboard"));

     let pollingStopped = false;
let tgUpdateOffset = 0;
async function captureAndSendToChat(chatId, caption) {
  try {
    const gridEl = document.querySelector(".grid");
    const canvas = await html2canvas(gridEl, { backgroundColor: "#cae1fa", scale: 2 });
    const blob = await new Promise(r => canvas.toBlob(r, "image/png"));

    const fd = new FormData();
    fd.append("chat_id", chatId);
    fd.append("caption", caption);
    fd.append("photo", blob, "charts.png");

    await fetch(`https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendPhoto`, {
      method: "POST",
      body: fd
    });
    console.log("‚úÖ ·∫¢nh ƒë√£ g·ª≠i Telegram");
  } catch (err) {
    console.error("‚ùå L·ªói captureAndSendToChat:", err);
  }
}

  document.getElementById('btnScanAll').addEventListener('click', () => {
  scanAllSymbols();
});

  </script>

</body>
</html>
